// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target arm64-apple-ios14.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Cancer200Api
import CoreGraphics
import CoreImage
import CoreLocation
import Foundation
import MapKit
import MessageUI
import PKHUD
import SnapKit
import Swift
import SwiftLocation
import UIKit
import UniformTypeIdentifiers
import _Concurrency
final public class FormRowDescriptor {
  public enum RowType {
    case unknown
    case label
    case text
    case url
    case number
    case numbersAndPunctuation
    case decimal
    case name
    case phone
    case namePhone
    case email
    case twitter
    case asciiCapable
    case password
    case button
    case booleanSwitch
    case booleanCheck
    case segmentedControl
    case picker
    case date
    case time
    case dateAndTime
    case stepper
    case slider
    case multipleSelector
    case multilineText
    public static func == (a: Cancer200Api.FormRowDescriptor.RowType, b: Cancer200Api.FormRowDescriptor.RowType) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct CellConfiguration {
    public var cellClass: Swift.AnyClass?
    public var appearance: [Swift.String : Swift.AnyObject]
    public var placeholder: Swift.String?
    public var showsInputToolbar: Swift.Bool
    public var required: Swift.Bool
    public var willUpdateClosure: ((Cancer200Api.FormRowDescriptor) -> Swift.Void)?
    public var didUpdateClosure: ((Cancer200Api.FormRowDescriptor) -> Swift.Void)?
    public var visualConstraintsClosure: ((Cancer200Api.FormBaseCell) -> [Swift.String])?
    public init()
  }
  public struct SelectionConfiguration {
    public var controllerClass: Swift.AnyClass?
    public var options: [Swift.AnyObject]
    public var optionTitleClosure: ((Swift.AnyObject) -> Swift.String)?
    public var allowsMultipleSelection: Swift.Bool
    public init()
  }
  public struct ButtonConfiguration {
    public var didSelectClosure: ((Cancer200Api.FormRowDescriptor) -> Swift.Void)?
    public init()
  }
  public struct StepperConfiguration {
    public var maximumValue: Swift.Double
    public var minimumValue: Swift.Double
    public var steps: Swift.Double
    public var continuous: Swift.Bool
    public init()
  }
  public struct DateConfiguration {
    public var dateFormatter: Foundation.DateFormatter?
  }
  public struct RowConfiguration {
    public var cell: Cancer200Api.FormRowDescriptor.CellConfiguration
    public var selection: Cancer200Api.FormRowDescriptor.SelectionConfiguration
    public var button: Cancer200Api.FormRowDescriptor.ButtonConfiguration
    public var stepper: Cancer200Api.FormRowDescriptor.StepperConfiguration
    public var date: Cancer200Api.FormRowDescriptor.DateConfiguration
    public var userInfo: [Swift.String : Swift.AnyObject]
  }
  final public let tag: Swift.String
  final public let type: Cancer200Api.FormRowDescriptor.RowType
  final public var title: Swift.String?
  final public var value: Swift.AnyObject? {
    get
    set
  }
  final public var configuration: Cancer200Api.FormRowDescriptor.RowConfiguration
  public init(tag: Swift.String, type: Cancer200Api.FormRowDescriptor.RowType, title: Swift.String, configuration: Cancer200Api.FormRowDescriptor.RowConfiguration)
  public init(tag: Swift.String, type: Cancer200Api.FormRowDescriptor.RowType, title: Swift.String)
  @objc deinit
}
extension Cancer200Api.Image {
  public enum Format {
    case png
    case jpeg(compressionQuality: Swift.Double)
    public struct FormattingError<I> : Swift.Error where I : Cancer200Api.ImageProtocol {
      public let image: I
      public let format: Cancer200Api.Image<Pixel>.Format
    }
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormBaseCell : UIKit.UITableViewCell {
  @_Concurrency.MainActor(unsafe) open var rowDescriptor: Cancer200Api.FormRowDescriptor? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) weak open var formViewController: Cancer200Api.FormViewController?
  @_Concurrency.MainActor(unsafe) @objc required override dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) open func configure()
  @_Concurrency.MainActor(unsafe) open func update()
  @_Concurrency.MainActor(unsafe) open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) open func firstResponderElement() -> UIKit.UIResponder?
  @_Concurrency.MainActor(unsafe) open func inputAccesoryView() -> UIKit.UIToolbar
  @_Concurrency.MainActor(unsafe) open class func formRowCellHeight() -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) open class func formRowCanBecomeFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) open class func formViewController(_ formViewController: Cancer200Api.FormViewController, didSelectRow: Cancer200Api.FormBaseCell)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func updateConstraints()
  @objc deinit
}
public typealias CurrentVectorBlock = (Cancer200Api.CurrentVector) -> Swift.Void
public typealias SimulationBlock = () -> Cancer200Api.GarminDetail
public typealias SimulationCache = [Swift.String : Cancer200Api.GarminDetail]
public typealias CustomSimulationCache = [Swift.String : Cancer200Api.Simulation]
public enum SimulationType : Swift.String, Swift.Codable {
  case basic
  case closestLand
  case bestOneBearing
  case bestTwoBearing
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum StartLocation : Swift.String, Swift.Codable {
  case kodomari
  case tappi
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct Track {
  public var name: Swift.String
  public var filename: Swift.String
  public init(_ name: Swift.String, _ filename: Swift.String)
}
public struct Simulation : Swift.Codable {
  public var name: Swift.String
  public var bearing: Swift.Double?
  public var bearingSecondHalf: Swift.Double?
  public var simulationStartName: Swift.String?
  public var simulationStartCoord: Cancer200Api.Coord?
  public var simulationName: Swift.String?
  public var simulationSwimmerName: Swift.String?
  public var simulationSwimmerPace: Swift.Double?
  public var simulationSwimStartTime: Foundation.Date?
  public var simulationDistance: Swift.Double?
  public var simulationDuration: Swift.Double?
  public var simulationType: Cancer200Api.SimulationType
  public var bestCalculated: Swift.Bool
  public var bestBearing: Swift.Double!
  public var bestBearingSecondHalf: Swift.Double!
  public var simulate: Cancer200Api.SimulationBlock
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
  public var totalRouteDistance: Swift.Double? {
    get
  }
  public var totalRouteDuration: Swift.Double? {
    get
  }
  public mutating func readCacheOrSimulate() -> Cancer200Api.GarminDetail
  public static func removeFromCache(name: Swift.String)
  public init(name: Swift.String, simulate: @escaping Cancer200Api.SimulationBlock, simulationType: Cancer200Api.SimulationType)
}
public struct TidePoint : Swift.Hashable {
  public var xVal: Swift.Int
  public var yVal: Swift.Int
  public init(xVal: Swift.Int, yVal: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Cancer200Api.TidePoint, rhs: Cancer200Api.TidePoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct CurrentVector : Swift.Codable {
  public init(startCoord: Cancer200Api.Coord, endCoord: Cancer200Api.Coord, distance: Swift.Double, direction: Swift.Double)
  public init(startCoord: Cancer200Api.Coord, endCoord: Cancer200Api.Coord)
  public init(startCoord: Cancer200Api.Coord, distance: Swift.Double, direction: Swift.Double)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormDateCell : Cancer200Api.FormValueCell {
  @_Concurrency.MainActor(unsafe) final public let datePicker: UIKit.UIDatePicker
  @_Concurrency.MainActor(unsafe) final public let defaultDateFormatter: Foundation.DateFormatter
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open class func formViewController(_ formViewController: Cancer200Api.FormViewController, didSelectRow selectedRow: Cancer200Api.FormBaseCell)
  @_Concurrency.MainActor(unsafe) override open func firstResponderElement() -> UIKit.UIResponder?
  @_Concurrency.MainActor(unsafe) override open class func formRowCanBecomeFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class FormOptionsSelectorController : UIKit.UITableViewController, Cancer200Api.FormSelector {
  @_Concurrency.MainActor(unsafe) @objc open var formCell: Cancer200Api.FormBaseCell?
  @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
}
extension Cancer200Api.ImageProtocol {
  public func resizedTo(width: Swift.Int, height: Swift.Int) -> Cancer200Api.Image<Self.Pixel>
}
extension Cancer200Api.ImageProtocol where Self.Element : Cancer200Api._NumericPixel {
  public func resizedTo(width: Swift.Int, height: Swift.Int) -> Cancer200Api.Image<Self.Pixel>
  public func resizedTo(width: Swift.Int, height: Swift.Int, interpolatedBy interpolationMethod: Cancer200Api.InterpolationMethod) -> Cancer200Api.Image<Self.Pixel>
}
extension Cancer200Api.RGBA where Channel == Swift.UInt8 {
  public init(red: Swift.UInt8, green: Swift.UInt8, blue: Swift.UInt8)
  public init(gray: Swift.UInt8)
  public static var red: Cancer200Api.RGBA<Swift.UInt8> {
    get
  }
  public static var green: Cancer200Api.RGBA<Swift.UInt8> {
    get
  }
  public static var blue: Cancer200Api.RGBA<Swift.UInt8> {
    get
  }
  public static var black: Cancer200Api.RGBA<Swift.UInt8> {
    get
  }
  public static var white: Cancer200Api.RGBA<Swift.UInt8> {
    get
  }
  public static var transparent: Cancer200Api.RGBA<Swift.UInt8> {
    get
  }
  public var gray: Swift.UInt8 {
    get
  }
  public var redInt: Swift.Int {
    get
    set
  }
  public var greenInt: Swift.Int {
    get
    set
  }
  public var blueInt: Swift.Int {
    get
    set
  }
  public var alphaInt: Swift.Int {
    get
    set
  }
  public var grayInt: Swift.Int {
    get
  }
}
extension Cancer200Api.RGBA where Channel == Swift.UInt16 {
  public init(red: Swift.UInt16, green: Swift.UInt16, blue: Swift.UInt16)
  public init(gray: Swift.UInt16)
  public static var red: Cancer200Api.RGBA<Swift.UInt16> {
    get
  }
  public static var green: Cancer200Api.RGBA<Swift.UInt16> {
    get
  }
  public static var blue: Cancer200Api.RGBA<Swift.UInt16> {
    get
  }
  public static var black: Cancer200Api.RGBA<Swift.UInt16> {
    get
  }
  public static var white: Cancer200Api.RGBA<Swift.UInt16> {
    get
  }
  public static var transparent: Cancer200Api.RGBA<Swift.UInt16> {
    get
  }
  public var gray: Swift.UInt16 {
    get
  }
  public var redInt: Swift.Int {
    get
    set
  }
  public var greenInt: Swift.Int {
    get
    set
  }
  public var blueInt: Swift.Int {
    get
    set
  }
  public var alphaInt: Swift.Int {
    get
    set
  }
  public var grayInt: Swift.Int {
    get
  }
}
extension Cancer200Api.RGBA where Channel == Swift.Float {
  public init(red: Swift.Float, green: Swift.Float, blue: Swift.Float)
  public init(gray: Swift.Float)
  public static var red: Cancer200Api.RGBA<Swift.Float> {
    get
  }
  public static var green: Cancer200Api.RGBA<Swift.Float> {
    get
  }
  public static var blue: Cancer200Api.RGBA<Swift.Float> {
    get
  }
  public static var black: Cancer200Api.RGBA<Swift.Float> {
    get
  }
  public static var white: Cancer200Api.RGBA<Swift.Float> {
    get
  }
  public static var transparent: Cancer200Api.RGBA<Swift.Float> {
    get
  }
  public var gray: Swift.Float {
    get
  }
}
extension Cancer200Api.RGBA where Channel == Swift.Double {
  public init(red: Swift.Double, green: Swift.Double, blue: Swift.Double)
  public init(gray: Swift.Double)
  public static var red: Cancer200Api.RGBA<Swift.Double> {
    get
  }
  public static var green: Cancer200Api.RGBA<Swift.Double> {
    get
  }
  public static var blue: Cancer200Api.RGBA<Swift.Double> {
    get
  }
  public static var black: Cancer200Api.RGBA<Swift.Double> {
    get
  }
  public static var white: Cancer200Api.RGBA<Swift.Double> {
    get
  }
  public static var transparent: Cancer200Api.RGBA<Swift.Double> {
    get
  }
  public var gray: Swift.Double {
    get
  }
}
extension Cancer200Api.RGBA where Channel == Swift.Int {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.Int8 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.Int16 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.Int32 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.Int64 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.UInt {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.UInt8 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.UInt16 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.UInt32 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.UInt64 {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.Float {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
extension Cancer200Api.RGBA where Channel == Swift.Double {
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Int64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt8>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt16>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt32>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.UInt64>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Float>)
  public init(_ rgba: Cancer200Api.RGBA<Swift.Double>)
}
final public class FormSectionDescriptor {
  final public var rows: [Cancer200Api.FormRowDescriptor]
  final public var headerTitle: Swift.String?
  final public var footerTitle: Swift.String?
  final public var headerView: UIKit.UIView?
  final public var footerView: UIKit.UIView?
  final public var headerViewHeight: CoreGraphics.CGFloat
  final public var footerViewHeight: CoreGraphics.CGFloat
  public init(headerTitle: Swift.String?, footerTitle: Swift.String?)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class Cancer200 {
  public static var instance: Cancer200Api.Cancer200
  public class func initApi()
  @objc deinit
  public func stopTracking()
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.UInt8> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.UInt16> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.Float> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.Double> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.Bool> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.UInt8> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.UInt16> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.Float> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.Double> {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Swift.UInt8 {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Swift.UInt16 {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Swift.Float {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Swift.Double {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.Image where Pixel == Swift.Bool {
  public init(uiImage: UIKit.UIImage)
  public init?(named name: Swift.String)
  public init?(named name: Swift.String, in bundle: Foundation.Bundle?, compatibleWith traitCollection: UIKit.UITraitCollection?)
  public init?(contentsOfFile path: Swift.String)
  public init?(data: Foundation.Data)
  public var uiImage: UIKit.UIImage {
    get
  }
  public func pngData() -> Foundation.Data?
  public func jpegData(compressionQuality: Swift.Double) -> Foundation.Data?
  public func data(using format: Cancer200Api.Image<Pixel>.Format) -> Foundation.Data?
  public func write(to url: Foundation.URL, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws
  public func write<S>(toFile path: S, atomically: Swift.Bool, format: Cancer200Api.Image<Pixel>.Format) throws where S : Swift.StringProtocol
}
extension Cancer200Api.ImageProtocol {
  public func rotated(byDegrees angle: Swift.Int) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(by angle: Swift.Double, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(byDegrees angle: Swift.Double, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.Image<Self.Pixel>
}
extension Cancer200Api.ImageProtocol where Self.Element : Cancer200Api._NumericPixel {
  public func rotated(byDegrees angle: Swift.Int) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(by angle: Swift.Double) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(byDegrees angle: Swift.Double) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(by angle: Swift.Double, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(byDegrees angle: Swift.Double, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(by angle: Swift.Double, interpolatedBy interpolationMethod: Cancer200Api.InterpolationMethod, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(byDegrees angle: Swift.Double, interpolatedBy interpolationMethod: Cancer200Api.InterpolationMethod, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.Image<Self.Pixel>
}
extension Cancer200Api.ImageProtocol where Self.Element == Swift.Bool {
  public func rotated(byDegrees angle: Swift.Int) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(by angle: Swift.Double) -> Cancer200Api.Image<Self.Pixel>
  public func rotated(byDegrees angle: Swift.Double) -> Cancer200Api.Image<Self.Pixel>
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormTitleCell : Cancer200Api.FormBaseCell {
  @objc @_Concurrency.MainActor(unsafe) final public let titleLabel: UIKit.UILabel
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) override open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormTextFieldCell : Cancer200Api.FormBaseCell {
  @_Concurrency.MainActor(unsafe) final public let titleLabel: UIKit.UILabel
  @objc @_Concurrency.MainActor(unsafe) final public let textField: UIKit.UITextField
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) override open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) override open func firstResponderElement() -> UIKit.UIResponder?
  @_Concurrency.MainActor(unsafe) override open class func formRowCanBecomeFirstResponder() -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Route {
  @objc deinit
}
public struct Image<Pixel> : Cancer200Api.ImageProtocol {
  public typealias SubImage = Cancer200Api.ImageSlice<Pixel>
  public let width: Swift.Int
  public let height: Swift.Int
  @usableFromInline
  internal var pixels: [Pixel]
  public init(width: Swift.Int, height: Swift.Int, pixels: [Pixel])
  public var xRange: Swift.Range<Swift.Int> {
    get
  }
  public var yRange: Swift.Range<Swift.Int> {
    get
  }
  public subscript(x: Swift.Int, y: Swift.Int) -> Pixel {
    get
    set
  }
  public subscript(xRange: Swift.Range<Swift.Int>, yRange: Swift.Range<Swift.Int>) -> Cancer200Api.ImageSlice<Pixel> {
    get
  }
  public typealias Element = Swift.IndexingIterator<[Pixel]>.Element
  public typealias Iterator = Swift.IndexingIterator<[Pixel]>
}
extension Cancer200Api.Image {
  public init(_ imageSlice: Cancer200Api.ImageSlice<Pixel>)
}
extension Cancer200Api.Image {
  public func makeIterator() -> Swift.IndexingIterator<[Pixel]>
}
extension Cancer200Api.Image {
  public func withUnsafeBufferPointer<R>(_ body: (Swift.UnsafeBufferPointer<Pixel>) throws -> R) rethrows -> R
  public mutating func withUnsafeMutableBufferPointer<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Pixel>) throws -> R) rethrows -> R
  public func withUnsafeBytes<R>(_ body: (Swift.UnsafeRawBufferPointer) throws -> R) rethrows -> R
  public mutating func withUnsafeMutableBytes<R>(_ body: (Swift.UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormStepperCell : Cancer200Api.FormTitleCell {
  @_Concurrency.MainActor(unsafe) final public let stepperView: UIKit.UIStepper
  @_Concurrency.MainActor(unsafe) final public let countLabel: UIKit.UILabel
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) override open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ExtendedFormLabelCell : Cancer200Api.FormLabelCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ExtendedFormTextFieldCell : Cancer200Api.FormTextFieldCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ExtendedFormSwitchCell : Cancer200Api.FormSwitchCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ExtendedFormButtonCell : Cancer200Api.FormButtonCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class ExtendedFormSelectorCell : Cancer200Api.FormSelectorCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public enum ExtrapolationMethod<Pixel> {
  case constant(Pixel)
  case edge
  case `repeat`
  case reflection
}
extension Cancer200Api.ImageProtocol {
  public subscript(x: Swift.Int, y: Swift.Int, extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Self.Pixel {
    get
  }
  @usableFromInline
  internal func extrapolatedPixelByFillingAt(x: Swift.Int, y: Swift.Int, by value: Self.Pixel) -> Self.Pixel
  @usableFromInline
  internal func extrapolatedPixelByEdgeAt(x: Swift.Int, y: Swift.Int, xRange: Swift.ClosedRange<Swift.Int>, yRange: Swift.ClosedRange<Swift.Int>) -> Self.Pixel
  @usableFromInline
  internal func extrapolatedPixelByRepeatAt(x: Swift.Int, y: Swift.Int, minX: Swift.Int, minY: Swift.Int, width: Swift.Int, height: Swift.Int) -> Self.Pixel
  @usableFromInline
  internal func extrapolatedPixelByReflectionAt(x: Swift.Int, y: Swift.Int, minX: Swift.Int, minY: Swift.Int, doubleWidth: Swift.Int, doubleHeight: Swift.Int, doubleWidthMinusOne: Swift.Int, doubleHeightMinusOne: Swift.Int) -> Self.Pixel
}
extension Cancer200Api.ImageProtocol {
  public subscript(xRange: Swift.Range<Swift.Int>, yRange: Swift.Range<Swift.Int>, extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.AnyImage<Self.Pixel> {
    get
  }
  public subscript<R1, R2>(xRange: R1, yRange: R2, extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.AnyImage<Self.Pixel> where R1 : Swift.RangeExpression, R2 : Swift.RangeExpression, R1.Bound == Swift.Int, R2.Bound == Swift.Int {
    get
  }
  public subscript<R1>(xRange: R1, yRange: (Swift.UnboundedRange_) -> (), extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.AnyImage<Self.Pixel> where R1 : Swift.RangeExpression, R1.Bound == Swift.Int {
    get
  }
  public subscript<R2>(xRange: (Swift.UnboundedRange_) -> (), yRange: R2, extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.AnyImage<Self.Pixel> where R2 : Swift.RangeExpression, R2.Bound == Swift.Int {
    get
  }
  public subscript(xRange: (Swift.UnboundedRange_) -> (), yRange: (Swift.UnboundedRange_) -> (), extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Cancer200Api.AnyImage<Self.Pixel> {
    get
  }
}
extension Cancer200Api.ImageProtocol {
  @inlinable public func map<T>(_ transform: (Self.Pixel) throws -> T) rethrows -> Cancer200Api.Image<T> {
        let pixels: [T] = try map(transform)
        return Image<T>(width: width, height: height, pixels: pixels)
    }
  @inlinable public mutating func update(_ body: (inout Self.Pixel) throws -> Swift.Void) rethrows {
        for y in yRange {
            for x in xRange {
                try body(&self[x, y])
            }
        }
    }
}
extension Cancer200Api.Image {
  @inlinable public mutating func update(_ body: (inout Pixel) throws -> Swift.Void) rethrows {
        let count = self.count
        guard count > 0 else { return }
        try pixels.withUnsafeMutableBufferPointer {
            for pointer in $0.baseAddress! ..< $0.baseAddress! + count {
                try body(&pointer.pointee)
            }
        }
    }
}
@_hasMissingDesignatedInitializers open class NotificationManager {
  public static let startUpdatingMap: Foundation.NSNotification.Name
  public static let stopUpdatingMap: Foundation.NSNotification.Name
  @objc deinit
}
extension Cancer200Api.RGBA where Channel : Swift.Numeric {
  @inlinable public static func + (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red + rhs.red, green: lhs.green + rhs.green, blue: lhs.blue + rhs.blue, alpha: lhs.alpha + rhs.alpha)
    }
  @inlinable public static func - (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red - rhs.red, green: lhs.green - rhs.green, blue: lhs.blue - rhs.blue, alpha: lhs.alpha - rhs.alpha)
    }
  @inlinable public static func * (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red * rhs.red, green: lhs.green * rhs.green, blue: lhs.blue * rhs.blue, alpha: lhs.alpha * rhs.alpha)
    }
  @inlinable public static func += (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red += rhs.red
        lhs.green += rhs.green
        lhs.blue += rhs.blue
        lhs.alpha += rhs.alpha
    }
  @inlinable public static func -= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red -= rhs.red
        lhs.green -= rhs.green
        lhs.blue -= rhs.blue
        lhs.alpha -= rhs.alpha
    }
  @inlinable public static func *= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red *= rhs.red
        lhs.green *= rhs.green
        lhs.blue *= rhs.blue
        lhs.alpha *= rhs.alpha
    }
  @inlinable prefix public static func + (a: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: +a.red, green: +a.green, blue: +a.blue, alpha: +a.alpha)
    }
}
extension Cancer200Api.RGBA where Channel : Swift.SignedNumeric {
  @inlinable prefix public static func - (a: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: -a.red, green: -a.green, blue: -a.blue, alpha: -a.alpha)
    }
}
extension Cancer200Api.RGBA where Channel : Swift.BinaryInteger {
  @inlinable public static func / (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red / rhs.red, green: lhs.green / rhs.green, blue: lhs.blue / rhs.blue, alpha: lhs.alpha / rhs.alpha)
    }
  @inlinable public static func % (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red % rhs.red, green: lhs.green % rhs.green, blue: lhs.blue % rhs.blue, alpha: lhs.alpha % rhs.alpha)
    }
  @inlinable public static func & (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red & rhs.red, green: lhs.green & rhs.green, blue: lhs.blue & rhs.blue, alpha: lhs.alpha & rhs.alpha)
    }
  @inlinable public static func | (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red | rhs.red, green: lhs.green | rhs.green, blue: lhs.blue | rhs.blue, alpha: lhs.alpha | rhs.alpha)
    }
  @inlinable public static func ^ (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red ^ rhs.red, green: lhs.green ^ rhs.green, blue: lhs.blue ^ rhs.blue, alpha: lhs.alpha ^ rhs.alpha)
    }
  @inlinable public static func << (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red << rhs.red, green: lhs.green << rhs.green, blue: lhs.blue << rhs.blue, alpha: lhs.alpha << rhs.alpha)
    }
  @inlinable public static func >> (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red >> rhs.red, green: lhs.green >> rhs.green, blue: lhs.blue >> rhs.blue, alpha: lhs.alpha >> rhs.alpha)
    }
  @inlinable public static func /= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red /= rhs.red
        lhs.green /= rhs.green
        lhs.blue /= rhs.blue
        lhs.alpha /= rhs.alpha
    }
  @inlinable public static func %= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red %= rhs.red
        lhs.green %= rhs.green
        lhs.blue %= rhs.blue
        lhs.alpha %= rhs.alpha
    }
  @inlinable public static func &= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red &= rhs.red
        lhs.green &= rhs.green
        lhs.blue &= rhs.blue
        lhs.alpha &= rhs.alpha
    }
  @inlinable public static func |= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red |= rhs.red
        lhs.green |= rhs.green
        lhs.blue |= rhs.blue
        lhs.alpha |= rhs.alpha
    }
  @inlinable public static func ^= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red ^= rhs.red
        lhs.green ^= rhs.green
        lhs.blue ^= rhs.blue
        lhs.alpha ^= rhs.alpha
    }
  @inlinable public static func <<= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red <<= rhs.red
        lhs.green <<= rhs.green
        lhs.blue <<= rhs.blue
        lhs.alpha <<= rhs.alpha
    }
  @inlinable public static func >>= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red >>= rhs.red
        lhs.green >>= rhs.green
        lhs.blue >>= rhs.blue
        lhs.alpha >>= rhs.alpha
    }
}
extension Cancer200Api.RGBA where Channel : Swift.FixedWidthInteger {
  @inlinable public static func &+ (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red &+ rhs.red, green: lhs.green &+ rhs.green, blue: lhs.blue &+ rhs.blue, alpha: lhs.alpha &+ rhs.alpha)
    }
  @inlinable public static func &- (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red &- rhs.red, green: lhs.green &- rhs.green, blue: lhs.blue &- rhs.blue, alpha: lhs.alpha &- rhs.alpha)
    }
  @inlinable public static func &* (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red &* rhs.red, green: lhs.green &* rhs.green, blue: lhs.blue &* rhs.blue, alpha: lhs.alpha &* rhs.alpha)
    }
  @inlinable public static func &<< (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red &<< rhs.red, green: lhs.green &<< rhs.green, blue: lhs.blue &<< rhs.blue, alpha: lhs.alpha &<< rhs.alpha)
    }
  @inlinable public static func &>> (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red &>> rhs.red, green: lhs.green &>> rhs.green, blue: lhs.blue &>> rhs.blue, alpha: lhs.alpha &>> rhs.alpha)
    }
  @inlinable public static func &<<= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red &<<= rhs.red
        lhs.green &<<= rhs.green
        lhs.blue &<<= rhs.blue
        lhs.alpha &<<= rhs.alpha
    }
  @inlinable public static func &>>= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red &>>= rhs.red
        lhs.green &>>= rhs.green
        lhs.blue &>>= rhs.blue
        lhs.alpha &>>= rhs.alpha
    }
}
extension Cancer200Api.RGBA where Channel : Swift.FloatingPoint {
  @inlinable public static func / (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red / rhs.red, green: lhs.green / rhs.green, blue: lhs.blue / rhs.blue, alpha: lhs.alpha / rhs.alpha)
    }
  @inlinable public static func /= (lhs: inout Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) {
        lhs.red /= rhs.red
        lhs.green /= rhs.green
        lhs.blue /= rhs.blue
        lhs.alpha /= rhs.alpha
    }
}
extension Cancer200Api.RGBA : Swift.Equatable where Channel : Swift.Equatable {
  @inlinable public static func == (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Swift.Bool {
        return lhs.red == rhs.red && lhs.green == rhs.green && lhs.blue == rhs.blue && lhs.alpha == rhs.alpha
    }
  @inlinable public static func != (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Swift.Bool {
        return lhs.red != rhs.red || lhs.green != rhs.green || lhs.blue != rhs.blue || lhs.alpha != rhs.alpha
    }
}
extension Cancer200Api.RGBA where Channel : Swift.Comparable {
  @inlinable public static func < (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Swift.Bool> {
        return RGBA<Bool>(red: lhs.red < rhs.red, green: lhs.green < rhs.green, blue: lhs.blue < rhs.blue, alpha: lhs.alpha < rhs.alpha)
    }
  @inlinable public static func <= (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Swift.Bool> {
        return RGBA<Bool>(red: lhs.red <= rhs.red, green: lhs.green <= rhs.green, blue: lhs.blue <= rhs.blue, alpha: lhs.alpha <= rhs.alpha)
    }
  @inlinable public static func > (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Swift.Bool> {
        return RGBA<Bool>(red: lhs.red > rhs.red, green: lhs.green > rhs.green, blue: lhs.blue > rhs.blue, alpha: lhs.alpha > rhs.alpha)
    }
  @inlinable public static func >= (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Swift.Bool> {
        return RGBA<Bool>(red: lhs.red >= rhs.red, green: lhs.green >= rhs.green, blue: lhs.blue >= rhs.blue, alpha: lhs.alpha >= rhs.alpha)
    }
}
extension Cancer200Api.RGBA where Channel == Swift.Bool {
  @inlinable public static func && (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red && rhs.red, green: lhs.green && rhs.green, blue: lhs.blue && rhs.blue, alpha: lhs.alpha && rhs.alpha)
    }
  @inlinable public static func || (lhs: Cancer200Api.RGBA<Channel>, rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: lhs.red || rhs.red, green: lhs.green || rhs.green, blue: lhs.blue || rhs.blue, alpha: lhs.alpha || rhs.alpha)
    }
  @inlinable prefix public static func ! (a: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA(red: !a.red, green: !a.green, blue: !a.blue, alpha: !a.alpha)
    }
}
public protocol ImageProtocol : Swift.Sequence {
  typealias Pixel = Self.Element
  associatedtype SubImage : Cancer200Api.ImageProtocol where Self.Element == Self.SubImage.Element, Self.SubImage.Element == Self.SubImage.SubImage.Element
  init(width: Swift.Int, height: Swift.Int, pixels: [Self.Pixel])
  var width: Swift.Int { get }
  var height: Swift.Int { get }
  var xRange: Swift.Range<Swift.Int> { get }
  var yRange: Swift.Range<Swift.Int> { get }
  subscript(x: Swift.Int, y: Swift.Int) -> Self.Pixel { get set }
  subscript(xRange: Swift.Range<Swift.Int>, yRange: Swift.Range<Swift.Int>) -> Self.SubImage { get }
  subscript<R1, R2>(xRange: R1, yRange: R2) -> Self.SubImage where R1 : Swift.RangeExpression, R2 : Swift.RangeExpression, R1.Bound == Swift.Int, R2.Bound == Swift.Int { get }
  subscript<R1>(xRange: R1, yRange: (Swift.UnboundedRange_) -> ()) -> Self.SubImage where R1 : Swift.RangeExpression, R1.Bound == Swift.Int { get }
  subscript<R2>(xRange: (Swift.UnboundedRange_) -> (), yRange: R2) -> Self.SubImage where R2 : Swift.RangeExpression, R2.Bound == Swift.Int { get }
  subscript(xRange: (Swift.UnboundedRange_) -> (), yRange: (Swift.UnboundedRange_) -> ()) -> Self.SubImage { get }
  func map<T>(_ transform: (Self.Pixel) throws -> T) rethrows -> Cancer200Api.Image<T>
  mutating func update(_ body: (inout Self.Pixel) throws -> Swift.Void) rethrows
}
extension Cancer200Api.ImageProtocol {
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public subscript<R1, R2>(xRange: R1, yRange: R2) -> Self.SubImage where R1 : Swift.RangeExpression, R2 : Swift.RangeExpression, R1.Bound == Swift.Int, R2.Bound == Swift.Int {
    get
  }
  public subscript<R1>(xRange: R1, yRange: (Swift.UnboundedRange_) -> ()) -> Self.SubImage where R1 : Swift.RangeExpression, R1.Bound == Swift.Int {
    get
  }
  public subscript<R2>(xRange: (Swift.UnboundedRange_) -> (), yRange: R2) -> Self.SubImage where R2 : Swift.RangeExpression, R2.Bound == Swift.Int {
    get
  }
  public subscript(xRange: (Swift.UnboundedRange_) -> (), yRange: (Swift.UnboundedRange_) -> ()) -> Self.SubImage {
    get
  }
  public func makeIterator() -> Cancer200Api.ImageIterator<Self>
}
extension Cancer200Api.ImageProtocol {
  public init()
  public init(pixel: Self.Pixel)
  public init(width: Swift.Int, height: Swift.Int, pixel: Self.Pixel)
  public init<S>(width: Swift.Int, height: Swift.Int, pixels: S) where S : Swift.Sequence, Self.Element == S.Element
  public init<I>(_ image: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element
  public init(width: Swift.Int, height: Swift.Int, pixelAt: (_ x: Swift.Int, _ y: Swift.Int) throws -> Self.Pixel) rethrows
  public var count: Swift.Int {
    get
  }
  public func pixelAt(x: Swift.Int, y: Swift.Int) -> Self.Pixel?
}
extension Cancer200Api.ImageProtocol {
  public func transposed() -> Cancer200Api.Image<Self.Pixel>
  public func xReversed() -> Cancer200Api.Image<Self.Pixel>
  public func yReversed() -> Cancer200Api.Image<Self.Pixel>
}
public let logger: Cancer200Api.TextLogger
@_hasMissingDesignatedInitializers public class TextLogger : Swift.TextOutputStream {
  public func debugLog(_ message: Swift.String)
  public func write(_ string: Swift.String)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormValueCell : Cancer200Api.FormBaseCell {
  @objc @_Concurrency.MainActor(unsafe) final public let titleLabel: UIKit.UILabel
  @objc @_Concurrency.MainActor(unsafe) final public let valueLabel: UIKit.UILabel
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) override open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension Cancer200Api.RGBA where Channel == Swift.UInt8 {
  public func isEqualToColor(color: Cancer200Api.RGBA<Swift.UInt8>, withTolerance tolerance: Swift.Double = 0.0) -> Swift.Bool
}
public struct Coord : Swift.Codable, Swift.Hashable {
  public init(_ latitude: Swift.Double, _ longitude: Swift.Double)
  public init(_ waypoint: Cancer200Api.WayPoint)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: Cancer200Api.Coord, rhs: Cancer200Api.Coord) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct RGBA<Channel> {
  public var red: Channel
  public var green: Channel
  public var blue: Channel
  public var alpha: Channel
  public init(red: Channel, green: Channel, blue: Channel, alpha: Channel)
}
extension Cancer200Api.RGBA {
  public init(gray: Channel, alpha: Channel)
}
extension Cancer200Api.RGBA {
  public func map<T>(_ transform: (Channel) -> T) -> Cancer200Api.RGBA<T>
}
extension Cancer200Api.RGBA where Channel == Swift.UInt8 {
  public init(_ rgbaInt: Swift.UInt32)
}
extension Cancer200Api.RGBA : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Cancer200Api.RGBA : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public protocol ConfigurationManagerProtocol {
  func event() -> Swift.String
  func eventName() -> Swift.String
  func googleAnalyticsTrackingId() -> Swift.String
  func bouysForEvent() -> [Cancer200Api.WayPoint]
  func routesForEvent() -> [Cancer200Api.Route]
  func maxCirclesForEvent() -> Swift.Int
  func swimmerTypesForEvent() -> [Swift.Int : Swift.String]
  func swimmerPaceForEvent() -> [Swift.Int : Swift.String]
  func aboutText() -> Swift.String
  func aboutTextColor() -> UIKit.UIColor
  func primaryBrandingColor() -> UIKit.UIColor
  func secondaryBrandingColor() -> UIKit.UIColor
}
@_hasMissingDesignatedInitializers public class ConfigurationManager {
  public static func aboutText() -> Swift.String
  public static func aboutTextColor() -> UIKit.UIColor
  public static func event() -> Swift.String
  public static func eventName() -> Swift.String
  public static func googleAnalyticsTrackingId() -> Swift.String
  public static func bouysForEvent() -> [Cancer200Api.WayPoint]
  public static func routesForEvent() -> [Cancer200Api.Route]
  public static func maxCirclesForEvent() -> Swift.Int
  public static func swimmerTypesForEvent() -> [Swift.Int : Swift.String]
  public static func swimmerPaceForEvent() -> [Swift.Int : Swift.String]
  public static func primaryBrandingColor() -> UIKit.UIColor
  public static func secondaryBrandingColor() -> UIKit.UIColor
  public enum AppType : Swift.String {
    case rottoswim
    case porttopub
    case tsugaru
    case cancer200ride
    case upallnight
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public static var appType: Cancer200Api.ConfigurationManager.AppType {
    get
  }
  public static var shared: Cancer200Api.ConfigurationManagerProtocol {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConfigurationManagerPortToPub : Cancer200Api.ConfigurationManagerProtocol {
  public func event() -> Swift.String
  public func eventName() -> Swift.String
  public func googleAnalyticsTrackingId() -> Swift.String
  public func routesForEvent() -> [Cancer200Api.Route]
  public func bouysForEvent() -> [Cancer200Api.WayPoint]
  public func maxCirclesForEvent() -> Swift.Int
  public func swimmerTypesForEvent() -> [Swift.Int : Swift.String]
  public func swimmerPaceForEvent() -> [Swift.Int : Swift.String]
  public func aboutText() -> Swift.String
  public func aboutTextColor() -> UIKit.UIColor
  public func primaryBrandingColor() -> UIKit.UIColor
  public func secondaryBrandingColor() -> UIKit.UIColor
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConfigurationManagerCancer200Ride : Cancer200Api.ConfigurationManagerProtocol {
  public func event() -> Swift.String
  public func eventName() -> Swift.String
  public func googleAnalyticsTrackingId() -> Swift.String
  public func routesForEvent() -> [Cancer200Api.Route]
  public func bouysForEvent() -> [Cancer200Api.WayPoint]
  public func maxCirclesForEvent() -> Swift.Int
  public func swimmerTypesForEvent() -> [Swift.Int : Swift.String]
  public func swimmerPaceForEvent() -> [Swift.Int : Swift.String]
  public func aboutText() -> Swift.String
  public func aboutTextColor() -> UIKit.UIColor
  public func primaryBrandingColor() -> UIKit.UIColor
  public func secondaryBrandingColor() -> UIKit.UIColor
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConfigurationManagerUpAllNight : Cancer200Api.ConfigurationManagerProtocol {
  public func event() -> Swift.String
  public func eventName() -> Swift.String
  public func googleAnalyticsTrackingId() -> Swift.String
  public func routesForEvent() -> [Cancer200Api.Route]
  public func bouysForEvent() -> [Cancer200Api.WayPoint]
  public func maxCirclesForEvent() -> Swift.Int
  public func swimmerTypesForEvent() -> [Swift.Int : Swift.String]
  public func swimmerPaceForEvent() -> [Swift.Int : Swift.String]
  public func aboutText() -> Swift.String
  public func aboutTextColor() -> UIKit.UIColor
  public func primaryBrandingColor() -> UIKit.UIColor
  public func secondaryBrandingColor() -> UIKit.UIColor
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConfigurationManagerMapSwim : Cancer200Api.ConfigurationManagerProtocol {
  public func event() -> Swift.String
  public func eventName() -> Swift.String
  public func googleAnalyticsTrackingId() -> Swift.String
  public func routesForEvent() -> [Cancer200Api.Route]
  public func bouysForEvent() -> [Cancer200Api.WayPoint]
  public func maxCirclesForEvent() -> Swift.Int
  public func swimmerTypesForEvent() -> [Swift.Int : Swift.String]
  public func swimmerPaceForEvent() -> [Swift.Int : Swift.String]
  public func aboutText() -> Swift.String
  public func aboutTextColor() -> UIKit.UIColor
  public func primaryBrandingColor() -> UIKit.UIColor
  public func secondaryBrandingColor() -> UIKit.UIColor
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConfigurationManagerTsugaru : Cancer200Api.ConfigurationManagerProtocol {
  public func event() -> Swift.String
  public func eventName() -> Swift.String
  public func googleAnalyticsTrackingId() -> Swift.String
  public func routesForEvent() -> [Cancer200Api.Route]
  public func bouysForEvent() -> [Cancer200Api.WayPoint]
  public func maxCirclesForEvent() -> Swift.Int
  public func swimmerTypesForEvent() -> [Swift.Int : Swift.String]
  public func swimmerPaceForEvent() -> [Swift.Int : Swift.String]
  public func aboutText() -> Swift.String
  public func aboutTextColor() -> UIKit.UIColor
  public func primaryBrandingColor() -> UIKit.UIColor
  public func secondaryBrandingColor() -> UIKit.UIColor
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class YearHelper : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
extension Cancer200Api.ImageProtocol where Self.Element : Swift.Numeric {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element : Swift.SignedNumeric {
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element : Swift.BinaryInteger {
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
}
extension Cancer200Api.ImageProtocol where Self.Element : Swift.FixedWidthInteger {
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
}
extension Cancer200Api.ImageProtocol where Self.Element : Swift.FloatingPoint {
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
}
extension Cancer200Api.Image : Swift.Equatable where Pixel : Swift.Equatable {
}
extension Cancer200Api.ImageSlice : Swift.Equatable where Pixel : Swift.Equatable {
}
extension Cancer200Api.ImageProtocol where Self.Element : Swift.Equatable {
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
}
extension Cancer200Api.ImageProtocol where Self.Element : Swift.Comparable {
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Swift.Bool> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<Bool>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Swift.Bool> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<Bool>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Swift.Bool> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<Bool>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Swift.Bool> where I : Cancer200Api.ImageProtocol, Self.Element == I.Element {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<Bool>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Swift.Bool {
  @inlinable public static func && <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Swift.Bool {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 && $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func || <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Swift.Bool {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`||` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 || $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func ! (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { !$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Int> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Int8> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Int16> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Int32> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Int64> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Int64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.UInt> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.UInt8> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt8> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.UInt16> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt16> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.UInt32> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt32> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.UInt64> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func % <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 % $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func & <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 & $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func | <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 | $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func ^ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 ^ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func << <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 << $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &+ <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &+ $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &- <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &- $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &* <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &* $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &<< <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &<< $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func &>> <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 &>> $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func %= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`%=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] %= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func |= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`|=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] |= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func ^= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`^=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] ^= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func <<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] <<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func >>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] >>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &<<= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&<<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &<<= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func &>>= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&>>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] &>>= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.UInt64> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Float> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Float> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Double> {
  @inlinable public static func + <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 + $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func - <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 - $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func * <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 * $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func / <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 / $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func += <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`+=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] += rhs[x2, y2]
            }
        }
    }
  @inlinable public static func -= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`-=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] -= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func *= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`*=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] *= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func /= <I>(lhs: inout Self, rhs: I) where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`/=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        for (y1, y2) in zip(lhs.yRange, rhs.yRange) {
            for (x1, x2) in zip(lhs.xRange, rhs.xRange) {
                lhs[x1, y1] /= rhs[x2, y2]
            }
        }
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
  @inlinable public static func < <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 < $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func <= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`<=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 <= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func > <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 > $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func >= <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Cancer200Api.RGBA<Swift.Bool>> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Double> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`>=` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 >= $1 }
        return Image<RGBA<Bool>>(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable prefix public static func + (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { +$0 })
    }
  @inlinable prefix public static func - (a: Self) -> Cancer200Api.Image<Self.Pixel> {
        return Image<Pixel>(width: a.width, height: a.height, pixels: a.map { -$0 })
    }
}
extension Cancer200Api.ImageProtocol where Self.Element == Cancer200Api.RGBA<Swift.Bool> {
  @inlinable public static func && <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Bool> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`&&` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 && $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func || <I>(lhs: Self, rhs: I) -> Cancer200Api.Image<Self.Pixel> where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Bool> {
        precondition(lhs.width == rhs.width && lhs.height == rhs.height, "`||` cannot be applied for images with different sizes: (\(lhs.width), \(lhs.height)), (\(rhs.width), \(rhs.height))")
        let pixels = zip(lhs, rhs).map { $0 || $1 }
        return Image(width: lhs.width, height: lhs.height, pixels: pixels)
    }
  @inlinable public static func == <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Bool> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return false }
        return zip(lhs, rhs).reduce(true) { $0 && $1.0 == $1.1 }
    }
  @inlinable public static func != <I>(lhs: Self, rhs: I) -> Swift.Bool where I : Cancer200Api.ImageProtocol, I.Element == Cancer200Api.RGBA<Swift.Bool> {
        guard lhs.width == rhs.width && lhs.height == rhs.height else { return true }
        return zip(lhs, rhs).reduce(false) { $0 || $1.0 != $1.1 }
    }
}
public let sharer: Cancer200Api.LocationSharer
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class LocationSharer : ObjectiveC.NSObject {
  open class func startUpdatingLocation()
  open class func stopUpdatingLocationIfUpdatingUnlessSharing()
  open class func startUpdatingLocationIfNotUpdating()
  open class func stopUpdatingLocation()
  open class func isUpdatingLocation() -> Swift.Bool
  open class func isSharingLocation() -> Swift.Bool
  @objc deinit
}
@objc public protocol FormSelector : ObjectiveC.NSObjectProtocol {
  @objc var formCell: Cancer200Api.FormBaseCell? { get set }
}
@objc @_hasMissingDesignatedInitializers public class WayPoint : CoreLocation.CLLocation, MapKit.MKAnnotation {
  @objc public var title: Swift.String?
  @objc public var subtitle: Swift.String?
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public struct ImageSlice<Pixel> : Cancer200Api.ImageProtocol {
  public typealias SubImage = Cancer200Api.ImageSlice<Pixel>
  public typealias Element = Pixel
  public let xRange: Swift.Range<Swift.Int>
  public let yRange: Swift.Range<Swift.Int>
  public init(width: Swift.Int, height: Swift.Int, pixels: [Pixel])
  public subscript(x: Swift.Int, y: Swift.Int) -> Pixel {
    get
    set
  }
  public subscript(xRange: Swift.Range<Swift.Int>, yRange: Swift.Range<Swift.Int>) -> Cancer200Api.ImageSlice<Pixel> {
    get
  }
  public typealias Iterator = Cancer200Api.ImageIterator<Cancer200Api.ImageSlice<Pixel>>
}
extension Cancer200Api.ImageSlice {
  public init(_ image: Cancer200Api.Image<Pixel>)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormSliderCell : Cancer200Api.FormTitleCell {
  @objc @_Concurrency.MainActor(unsafe) final public let sliderView: UIKit.UISlider
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) override open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormViewController : UIKit.UITableViewController {
  @_Concurrency.MainActor(unsafe) open var form: Cancer200Api.FormDescriptor
  @objc convenience dynamic public init()
  @_Concurrency.MainActor(unsafe) convenience public init(form: Cancer200Api.FormDescriptor)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(style: UIKit.UITableView.Style)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) open func valueForTag(_ tag: Swift.String) -> Swift.AnyObject?
  @_Concurrency.MainActor(unsafe) open func setValue(_ value: Swift.AnyObject, forTag tag: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func numberOfSections(in tableView: UIKit.UITableView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, numberOfRowsInSection section: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, cellForRowAt indexPath: Foundation.IndexPath) -> UIKit.UITableViewCell
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, titleForHeaderInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, titleForFooterInSection section: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, viewForFooterInSection section: Swift.Int) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, viewForHeaderInSection section: Swift.Int) -> UIKit.UIView?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, heightForHeaderInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, heightForFooterInSection section: Swift.Int) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, heightForRowAt indexPath: Foundation.IndexPath) -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func tableView(_ tableView: UIKit.UITableView, didSelectRowAt indexPath: Foundation.IndexPath)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormSelectorCell : Cancer200Api.FormValueCell {
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open class func formViewController(_ formViewController: Cancer200Api.FormViewController, didSelectRow selectedRow: Cancer200Api.FormBaseCell)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public enum CGContextCoordinates {
  case original
  case natural
  public static func == (a: Cancer200Api.CGContextCoordinates, b: Cancer200Api.CGContextCoordinates) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.UInt8> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.UInt16> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.Float> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.Double> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Cancer200Api.RGBA<Swift.Bool> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.UInt8> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.UInt16> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.Float> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Cancer200Api.PremultipliedRGBA<Swift.Double> {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Swift.UInt8 {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
extension Cancer200Api.Image where Pixel == Swift.UInt16 {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
extension Cancer200Api.Image where Pixel == Swift.Float {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Swift.Double {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.Image where Pixel == Swift.Bool {
  public init(cgImage: CoreGraphics.CGImage)
  public var cgImage: CoreGraphics.CGImage {
    get
  }
}
extension Cancer200Api.ImageSlice where Pixel == Cancer200Api.PremultipliedRGBA<Swift.UInt8> {
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
extension Cancer200Api.ImageSlice where Pixel == Cancer200Api.PremultipliedRGBA<Swift.UInt16> {
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
extension Cancer200Api.ImageSlice where Pixel == Swift.UInt8 {
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
extension Cancer200Api.ImageSlice where Pixel == Swift.UInt16 {
  public var cgImage: CoreGraphics.CGImage {
    get
  }
  public func withCGImage<R>(_ body: (CoreGraphics.CGImage) throws -> R) rethrows -> R
  public mutating func withCGContext(coordinates: Cancer200Api.CGContextCoordinates = .natural, _ body: (CoreGraphics.CGContext) throws -> Swift.Void) rethrows
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormPickerCell : Cancer200Api.FormValueCell, UIKit.UIPickerViewDelegate, UIKit.UIPickerViewDataSource {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open func firstResponderElement() -> UIKit.UIResponder?
  @_Concurrency.MainActor(unsafe) override open class func formViewController(_ formViewController: Cancer200Api.FormViewController, didSelectRow selectedRow: Cancer200Api.FormBaseCell)
  @_Concurrency.MainActor(unsafe) @objc open func pickerView(_ pickerView: UIKit.UIPickerView, titleForRow row: Swift.Int, forComponent component: Swift.Int) -> Swift.String?
  @_Concurrency.MainActor(unsafe) @objc open func pickerView(_ pickerView: UIKit.UIPickerView, didSelectRow row: Swift.Int, inComponent component: Swift.Int)
  @_Concurrency.MainActor(unsafe) @objc open func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc open func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension Cancer200Api.ImageProtocol where Self.Element : Cancer200Api._NumericPixel {
  @inlinable public func convoluted<Kernel>(with kernel: Kernel, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel> = .edge) -> Cancer200Api.Image<Self.Pixel> where Kernel : Cancer200Api.ImageProtocol, Kernel.Element == Swift.Int {
        switch extrapolationMethod {
        case .constant(let value):
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByFillingAt(x: x, y: y, by: value)
            }
        case .edge:
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByEdgeAt(x: x, y: y, xRange: ClosedRange(xRange), yRange: ClosedRange(yRange))
            }
        case .repeat:
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByRepeatAt(x: x, y: y, minX: xRange.lowerBound, minY: yRange.lowerBound, width: width, height: height)
            }
        case .reflection:
            let doubleWidth = width * 2
            let doubleHeight = height * 2
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByReflectionAt(
                    x: x,
                    y: y,
                    minX: xRange.lowerBound,
                    minY: yRange.lowerBound,
                    doubleWidth: doubleWidth,
                    doubleHeight: doubleHeight,
                    doubleWidthMinusOne: doubleWidth - 1,
                    doubleHeightMinusOne: doubleHeight - 1
                )
            }
        }
    }
  @inlinable public func convoluted<Kernel>(with kernel: Kernel, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel> = .edge) -> Cancer200Api.Image<Self.Pixel> where Kernel : Cancer200Api.ImageProtocol, Kernel.Element == Swift.Float {
        switch extrapolationMethod {
        case .constant(let value):
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByFillingAt(x: x, y: y, by: value)
            }
        case .edge:
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByEdgeAt(x: x, y: y, xRange: ClosedRange(xRange), yRange: ClosedRange(yRange))
            }
        case .repeat:
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByRepeatAt(x: x, y: y, minX: xRange.lowerBound, minY: yRange.lowerBound, width: width, height: height)
            }
        case .reflection:
            let doubleWidth = width * 2
            let doubleHeight = height * 2
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByReflectionAt(
                    x: x,
                    y: y,
                    minX: xRange.lowerBound,
                    minY: yRange.lowerBound,
                    doubleWidth: doubleWidth,
                    doubleHeight: doubleHeight,
                    doubleWidthMinusOne: doubleWidth - 1,
                    doubleHeightMinusOne: doubleHeight - 1
                )
            }
        }
    }
  @inlinable public func convoluted<Kernel>(with kernel: Kernel, extrapolatedBy extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel> = .edge) -> Cancer200Api.Image<Self.Pixel> where Kernel : Cancer200Api.ImageProtocol, Kernel.Element == Swift.Double {
        switch extrapolationMethod {
        case .constant(let value):
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByFillingAt(x: x, y: y, by: value)
            }
        case .edge:
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByEdgeAt(x: x, y: y, xRange: ClosedRange(xRange), yRange: ClosedRange(yRange))
            }
        case .repeat:
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByRepeatAt(x: x, y: y, minX: xRange.lowerBound, minY: yRange.lowerBound, width: width, height: height)
            }
        case .reflection:
            let doubleWidth = width * 2
            let doubleHeight = height * 2
            return _convoluted(with: kernel) { x, y in
                extrapolatedPixelByReflectionAt(
                    x: x,
                    y: y,
                    minX: xRange.lowerBound,
                    minY: yRange.lowerBound,
                    doubleWidth: doubleWidth,
                    doubleHeight: doubleHeight,
                    doubleWidthMinusOne: doubleWidth - 1,
                    doubleHeightMinusOne: doubleHeight - 1
                )
            }
        }
    }
  @usableFromInline
  internal func _convoluted<Kernel>(with kernel: Kernel, pixelAt: (Swift.Int, Swift.Int) -> Self.Pixel) -> Cancer200Api.Image<Self.Pixel> where Kernel : Cancer200Api.ImageProtocol, Kernel.Element == Swift.Int
  @usableFromInline
  internal func _convoluted<Kernel>(with kernel: Kernel, pixelAt: (Swift.Int, Swift.Int) -> Self.Pixel) -> Cancer200Api.Image<Self.Pixel> where Kernel : Cancer200Api.ImageProtocol, Kernel.Element == Swift.Float
  @usableFromInline
  internal func _convoluted<Kernel>(with kernel: Kernel, pixelAt: (Swift.Int, Swift.Int) -> Self.Pixel) -> Cancer200Api.Image<Self.Pixel> where Kernel : Cancer200Api.ImageProtocol, Kernel.Element == Swift.Double
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class MapViewController : UIKit.UIViewController, CoreLocation.CLLocationManagerDelegate {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidDisappear(_ animated: Swift.Bool)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc public func locationManager(_ manager: CoreLocation.CLLocationManager, didChangeAuthorization status: CoreLocation.CLAuthorizationStatus)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didReceiveMemoryWarning()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var tabBarItem: UIKit.UITabBarItem! {
    @_Concurrency.MainActor(unsafe) @objc get
    @_Concurrency.MainActor(unsafe) @objc set(newValue)
  }
  @objc deinit
}
extension Cancer200Api.MapViewController : MapKit.MKMapViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, rendererFor overlay: MapKit.MKOverlay) -> MapKit.MKOverlayRenderer
  public typealias ProcessTrackBlock = (Cancer200Api.GarminDetail) -> Swift.Void
  public typealias ProcessTrackCompletionBlock = () -> Swift.Void
  @_Concurrency.MainActor(unsafe) public func addCustomRouteFromGpx(_ gpxURL: Foundation.URL)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, didSelect view: MapKit.MKAnnotationView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func mapView(_ mapView: MapKit.MKMapView, viewFor annotation: MapKit.MKAnnotation) -> MapKit.MKAnnotationView?
}
public protocol _Summable {
  static func _ez_sum(_ lhs: Self, _ rhs: Self) -> Self
}
extension Swift.Int : Cancer200Api._Summable {
  public static func _ez_sum(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int
}
extension Swift.Int64 : Cancer200Api._Summable {
  public static func _ez_sum(_ lhs: Swift.Int64, _ rhs: Swift.Int64) -> Swift.Int64
}
extension Swift.Float : Cancer200Api._Summable {
  public static func _ez_sum(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
}
extension Swift.Double : Cancer200Api._Summable {
  public static func _ez_sum(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
}
extension Cancer200Api.RGBA : Cancer200Api._Summable where Channel : Cancer200Api._Summable {
  @inlinable public static func _ez_sum(_ lhs: Cancer200Api.RGBA<Channel>, _ rhs: Cancer200Api.RGBA<Channel>) -> Cancer200Api.RGBA<Channel> {
        return RGBA<Channel>(
            red: Channel._ez_sum(lhs.red, rhs.red),
            green: Channel._ez_sum(lhs.green, rhs.green),
            blue: Channel._ez_sum(lhs.blue, rhs.blue),
            alpha: Channel._ez_sum(lhs.alpha, rhs.alpha)
        )
    }
}
public protocol _NumericPixel {
  associatedtype _NumericPixelSummableInt : Cancer200Api._Summable
  associatedtype _NumericPixelSummableFloat : Cancer200Api._Summable
  associatedtype _NumericPixelSummableDouble : Cancer200Api._Summable
  init(_ez_summableInt: Self._NumericPixelSummableInt)
  init(_ez_summableFloat: Self._NumericPixelSummableFloat)
  init(_ez_summableDouble: Self._NumericPixelSummableDouble)
  var _ez_summableInt: Self._NumericPixelSummableInt { get }
  var _ez_summableFloat: Self._NumericPixelSummableFloat { get }
  var _ez_summableDouble: Self._NumericPixelSummableDouble { get }
  static var _ez_zero: Self { get }
  static var _ez_summableIntZero: Self._NumericPixelSummableInt { get }
  static var _ez_summableFloatZero: Self._NumericPixelSummableFloat { get }
  static var _ez_summableDoubleZero: Self._NumericPixelSummableDouble { get }
  static func _ez_productInt(_ lhs: Self._NumericPixelSummableInt, _ rhs: Swift.Int) -> Self._NumericPixelSummableInt
  static func _ez_productFloat(_ lhs: Self._NumericPixelSummableFloat, _ rhs: Swift.Float) -> Self._NumericPixelSummableFloat
  static func _ez_productDouble(_ lhs: Self._NumericPixelSummableDouble, _ rhs: Swift.Double) -> Self._NumericPixelSummableDouble
  static func _ez_quotientInt(_ lhs: Self._NumericPixelSummableInt, _ rhs: Swift.Int) -> Self._NumericPixelSummableInt
  static func _ez_quotientFloat(_ lhs: Self._NumericPixelSummableFloat, _ rhs: Swift.Float) -> Self._NumericPixelSummableFloat
  static func _ez_quotientDouble(_ lhs: Self._NumericPixelSummableDouble, _ rhs: Swift.Double) -> Self._NumericPixelSummableDouble
}
extension Cancer200Api.RGBA : Cancer200Api._NumericPixel where Channel : Cancer200Api._NumericPixel {
  public typealias _NumericPixelSummableInt = Cancer200Api.RGBA<Channel._NumericPixelSummableInt>
  public typealias _NumericPixelSummableFloat = Cancer200Api.RGBA<Channel._NumericPixelSummableFloat>
  public typealias _NumericPixelSummableDouble = Cancer200Api.RGBA<Channel._NumericPixelSummableDouble>
  @inlinable public init(_ez_summableInt: Cancer200Api.RGBA<Channel._NumericPixelSummableInt>) {
        self = RGBA<Channel>(red: Channel(_ez_summableInt: _ez_summableInt.red), green: Channel(_ez_summableInt: _ez_summableInt.green), blue: Channel(_ez_summableInt: _ez_summableInt.blue), alpha: Channel(_ez_summableInt: _ez_summableInt.alpha))
    }
  @inlinable public init(_ez_summableFloat: Cancer200Api.RGBA<Channel._NumericPixelSummableFloat>) {
        self = RGBA<Channel>(red: Channel(_ez_summableFloat: _ez_summableFloat.red), green: Channel(_ez_summableFloat: _ez_summableFloat.green), blue: Channel(_ez_summableFloat: _ez_summableFloat.blue), alpha: Channel(_ez_summableFloat: _ez_summableFloat.alpha))
    }
  @inlinable public init(_ez_summableDouble: Cancer200Api.RGBA<Channel._NumericPixelSummableDouble>) {
        self = RGBA<Channel>(red: Channel(_ez_summableDouble: _ez_summableDouble.red), green: Channel(_ez_summableDouble: _ez_summableDouble.green), blue: Channel(_ez_summableDouble: _ez_summableDouble.blue), alpha: Channel(_ez_summableDouble: _ez_summableDouble.alpha))
    }
  public var _ez_summableInt: Cancer200Api.RGBA<Channel._NumericPixelSummableInt> {
    get
  }
  public var _ez_summableFloat: Cancer200Api.RGBA<Channel._NumericPixelSummableFloat> {
    get
  }
  public var _ez_summableDouble: Cancer200Api.RGBA<Channel._NumericPixelSummableDouble> {
    get
  }
  public static var _ez_zero: Cancer200Api.RGBA<Channel> {
    get
  }
  public static var _ez_summableIntZero: Cancer200Api.RGBA<Channel._NumericPixelSummableInt> {
    get
  }
  public static var _ez_summableFloatZero: Cancer200Api.RGBA<Channel._NumericPixelSummableFloat> {
    get
  }
  public static var _ez_summableDoubleZero: Cancer200Api.RGBA<Channel._NumericPixelSummableDouble> {
    get
  }
  @inlinable public static func _ez_productInt(_ lhs: Cancer200Api.RGBA<Channel._NumericPixelSummableInt>, _ rhs: Swift.Int) -> Cancer200Api.RGBA<Channel._NumericPixelSummableInt> {
        return RGBA<Channel._NumericPixelSummableInt>(red: Channel._ez_productInt(lhs.red, rhs), green: Channel._ez_productInt(lhs.green, rhs), blue: Channel._ez_productInt(lhs.blue, rhs), alpha: Channel._ez_productInt(lhs.alpha, rhs))
    }
  @inlinable public static func _ez_productFloat(_ lhs: Cancer200Api.RGBA<Channel._NumericPixelSummableFloat>, _ rhs: Swift.Float) -> Cancer200Api.RGBA<Channel._NumericPixelSummableFloat> {
        return RGBA<Channel._NumericPixelSummableFloat>(red: Channel._ez_productFloat(lhs.red, rhs), green: Channel._ez_productFloat(lhs.green, rhs), blue: Channel._ez_productFloat(lhs.blue, rhs), alpha: Channel._ez_productFloat(lhs.alpha, rhs))
    }
  @inlinable public static func _ez_productDouble(_ lhs: Cancer200Api.RGBA<Channel._NumericPixelSummableDouble>, _ rhs: Swift.Double) -> Cancer200Api.RGBA<Channel._NumericPixelSummableDouble> {
        return RGBA<Channel._NumericPixelSummableDouble>(red: Channel._ez_productDouble(lhs.red, rhs), green: Channel._ez_productDouble(lhs.green, rhs), blue: Channel._ez_productDouble(lhs.blue, rhs), alpha: Channel._ez_productDouble(lhs.alpha, rhs))
    }
  @inlinable public static func _ez_quotientInt(_ lhs: Cancer200Api.RGBA<Channel._NumericPixelSummableInt>, _ rhs: Swift.Int) -> Cancer200Api.RGBA<Channel._NumericPixelSummableInt> {
        return RGBA<Channel._NumericPixelSummableInt>(red: Channel._ez_quotientInt(lhs.red, rhs), green: Channel._ez_quotientInt(lhs.green, rhs), blue: Channel._ez_quotientInt(lhs.blue, rhs), alpha: Channel._ez_quotientInt(lhs.alpha, rhs))
    }
  @inlinable public static func _ez_quotientFloat(_ lhs: Cancer200Api.RGBA<Channel._NumericPixelSummableFloat>, _ rhs: Swift.Float) -> Cancer200Api.RGBA<Channel._NumericPixelSummableFloat> {
        return RGBA<Channel._NumericPixelSummableFloat>(red: Channel._ez_quotientFloat(lhs.red, rhs), green: Channel._ez_quotientFloat(lhs.green, rhs), blue: Channel._ez_quotientFloat(lhs.blue, rhs), alpha: Channel._ez_quotientFloat(lhs.alpha, rhs))
    }
  @inlinable public static func _ez_quotientDouble(_ lhs: Cancer200Api.RGBA<Channel._NumericPixelSummableDouble>, _ rhs: Swift.Double) -> Cancer200Api.RGBA<Channel._NumericPixelSummableDouble> {
        return RGBA<Channel._NumericPixelSummableDouble>(red: Channel._ez_quotientDouble(lhs.red, rhs), green: Channel._ez_quotientDouble(lhs.green, rhs), blue: Channel._ez_quotientDouble(lhs.blue, rhs), alpha: Channel._ez_quotientDouble(lhs.alpha, rhs))
    }
}
extension Swift.UInt8 : Cancer200Api._NumericPixel {
  public init(_ez_summableInt: Swift.Int)
  public init(_ez_summableFloat: Swift.Float)
  public init(_ez_summableDouble: Swift.Double)
  public var _ez_summableInt: Swift.Int {
    get
  }
  public var _ez_summableFloat: Swift.Float {
    get
  }
  public var _ez_summableDouble: Swift.Double {
    get
  }
  public static var _ez_zero: Swift.UInt8 {
    get
  }
  public static var _ez_summableIntZero: Swift.Int {
    get
  }
  public static var _ez_summableFloatZero: Swift.Float {
    get
  }
  public static var _ez_summableDoubleZero: Swift.Double {
    get
  }
  public static func _ez_productInt(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int
  public static func _ez_productFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_productDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public static func _ez_quotientInt(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int
  public static func _ez_quotientFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_quotientDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public typealias _NumericPixelSummableDouble = Swift.Double
  public typealias _NumericPixelSummableFloat = Swift.Float
  public typealias _NumericPixelSummableInt = Swift.Int
}
extension Swift.UInt16 : Cancer200Api._NumericPixel {
  public init(_ez_summableInt: Swift.Int)
  public init(_ez_summableFloat: Swift.Float)
  public init(_ez_summableDouble: Swift.Double)
  public var _ez_summableInt: Swift.Int {
    get
  }
  public var _ez_summableFloat: Swift.Float {
    get
  }
  public var _ez_summableDouble: Swift.Double {
    get
  }
  public static var _ez_zero: Swift.UInt16 {
    get
  }
  public static var _ez_summableIntZero: Swift.Int {
    get
  }
  public static var _ez_summableFloatZero: Swift.Float {
    get
  }
  public static var _ez_summableDoubleZero: Swift.Double {
    get
  }
  public static func _ez_productInt(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int
  public static func _ez_productFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_productDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public static func _ez_quotientInt(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int
  public static func _ez_quotientFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_quotientDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public typealias _NumericPixelSummableDouble = Swift.Double
  public typealias _NumericPixelSummableFloat = Swift.Float
  public typealias _NumericPixelSummableInt = Swift.Int
}
extension Swift.Int : Cancer200Api._NumericPixel {
  public init(_ez_summableInt: Swift.Int)
  public init(_ez_summableFloat: Swift.Float)
  public init(_ez_summableDouble: Swift.Double)
  public var _ez_summableInt: Swift.Int {
    get
  }
  public var _ez_summableFloat: Swift.Float {
    get
  }
  public var _ez_summableDouble: Swift.Double {
    get
  }
  public static var _ez_zero: Swift.Int {
    get
  }
  public static var _ez_summableIntZero: Swift.Int {
    get
  }
  public static var _ez_summableFloatZero: Swift.Float {
    get
  }
  public static var _ez_summableDoubleZero: Swift.Double {
    get
  }
  public static func _ez_productInt(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int
  public static func _ez_productFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_productDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public static func _ez_quotientInt(_ lhs: Swift.Int, _ rhs: Swift.Int) -> Swift.Int
  public static func _ez_quotientFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_quotientDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public typealias _NumericPixelSummableDouble = Swift.Double
  public typealias _NumericPixelSummableFloat = Swift.Float
  public typealias _NumericPixelSummableInt = Swift.Int
}
extension Swift.Float : Cancer200Api._NumericPixel {
  public init(_ez_summableInt: Swift.Float)
  public init(_ez_summableFloat: Swift.Float)
  public init(_ez_summableDouble: Swift.Double)
  public var _ez_summableInt: Swift.Float {
    get
  }
  public var _ez_summableFloat: Swift.Float {
    get
  }
  public var _ez_summableDouble: Swift.Double {
    get
  }
  public static var _ez_zero: Swift.Float {
    get
  }
  public static var _ez_summableIntZero: Swift.Float {
    get
  }
  public static var _ez_summableFloatZero: Swift.Float {
    get
  }
  public static var _ez_summableDoubleZero: Swift.Double {
    get
  }
  public static func _ez_productInt(_ lhs: Swift.Float, _ rhs: Swift.Int) -> Swift.Float
  public static func _ez_productFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_productDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public static func _ez_quotientInt(_ lhs: Swift.Float, _ rhs: Swift.Int) -> Swift.Float
  public static func _ez_quotientFloat(_ lhs: Swift.Float, _ rhs: Swift.Float) -> Swift.Float
  public static func _ez_quotientDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public typealias _NumericPixelSummableDouble = Swift.Double
  public typealias _NumericPixelSummableFloat = Swift.Float
  public typealias _NumericPixelSummableInt = Swift.Float
}
extension Swift.Double : Cancer200Api._NumericPixel {
  public init(_ez_summableInt: Swift.Double)
  public init(_ez_summableFloat: Swift.Double)
  public init(_ez_summableDouble: Swift.Double)
  public var _ez_summableInt: Swift.Double {
    get
  }
  public var _ez_summableFloat: Swift.Double {
    get
  }
  public var _ez_summableDouble: Swift.Double {
    get
  }
  public static var _ez_zero: Swift.Double {
    get
  }
  public static var _ez_summableIntZero: Swift.Double {
    get
  }
  public static var _ez_summableFloatZero: Swift.Double {
    get
  }
  public static var _ez_summableDoubleZero: Swift.Double {
    get
  }
  public static func _ez_productInt(_ lhs: Swift.Double, _ rhs: Swift.Int) -> Swift.Double
  public static func _ez_productFloat(_ lhs: Swift.Double, _ rhs: Swift.Float) -> Swift.Double
  public static func _ez_productDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public static func _ez_quotientInt(_ lhs: Swift.Double, _ rhs: Swift.Int) -> Swift.Double
  public static func _ez_quotientFloat(_ lhs: Swift.Double, _ rhs: Swift.Float) -> Swift.Double
  public static func _ez_quotientDouble(_ lhs: Swift.Double, _ rhs: Swift.Double) -> Swift.Double
  public typealias _NumericPixelSummableDouble = Swift.Double
  public typealias _NumericPixelSummableFloat = Swift.Double
  public typealias _NumericPixelSummableInt = Swift.Double
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormButtonCell : Cancer200Api.FormTitleCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public struct GarminPoint : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public struct GarminDetail : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public enum InterpolationMethod {
  case nearestNeighbor
  case bilinear
  public static func == (a: Cancer200Api.InterpolationMethod, b: Cancer200Api.InterpolationMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Cancer200Api.ImageProtocol {
  public subscript(x: Swift.Double, y: Swift.Double) -> Self.Pixel {
    get
  }
  public subscript(x: Swift.Double, y: Swift.Double, extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Self.Pixel {
    get
  }
}
extension Cancer200Api.ImageProtocol where Self.Element : Cancer200Api._NumericPixel {
  public subscript(x: Swift.Double, y: Swift.Double) -> Self.Pixel {
    get
  }
  public subscript(x: Swift.Double, y: Swift.Double, interpolation interpolationMethod: Cancer200Api.InterpolationMethod) -> Self.Pixel {
    get
  }
  public subscript(x: Swift.Double, y: Swift.Double, extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Self.Pixel {
    get
  }
  public subscript(x: Swift.Double, y: Swift.Double, interpolation interpolationMethod: Cancer200Api.InterpolationMethod, extrapolation extrapolationMethod: Cancer200Api.ExtrapolationMethod<Self.Pixel>) -> Self.Pixel {
    get
  }
}
@_inheritsConvenienceInitializers @objc(FormSegmentedControlCell) @_Concurrency.MainActor(unsafe) open class FormSegmentedControlCell : Cancer200Api.FormBaseCell {
  @objc @_Concurrency.MainActor(unsafe) final public let titleLabel: UIKit.UILabel
  @objc @_Concurrency.MainActor(unsafe) final public let segmentedControl: UIKit.UISegmentedControl
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) override open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormTextViewCell : Cancer200Api.FormBaseCell, UIKit.UITextViewDelegate {
  @objc @_Concurrency.MainActor(unsafe) final public let titleLabel: UIKit.UILabel
  @objc @_Concurrency.MainActor(unsafe) final public let textField: UIKit.UITextView
  @_Concurrency.MainActor(unsafe) override open class func formRowCellHeight() -> CoreGraphics.CGFloat
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open func constraintsViews() -> [Swift.String : UIKit.UIView]
  @_Concurrency.MainActor(unsafe) override open func defaultVisualConstraints() -> [Swift.String]
  @_Concurrency.MainActor(unsafe) @objc open func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormSwitchCell : Cancer200Api.FormTitleCell {
  @_Concurrency.MainActor(unsafe) final public let switchView: UIKit.UISwitch
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public struct AnyImage<Pixel> : Cancer200Api.ImageProtocol {
  public typealias SubImage = Cancer200Api.AnyImage<Pixel>
  public typealias Element = Pixel
  public let xRange: Swift.Range<Swift.Int>
  public let yRange: Swift.Range<Swift.Int>
  public init<I>(_ image: I) where Pixel == I.Element, I : Cancer200Api.ImageProtocol
  public init(width: Swift.Int, height: Swift.Int, pixels: [Pixel])
  public subscript(x: Swift.Int, y: Swift.Int) -> Pixel {
    get
    set
  }
  public subscript(xRange: Swift.Range<Swift.Int>, yRange: Swift.Range<Swift.Int>) -> Cancer200Api.AnyImage<Pixel> {
    get
  }
  public typealias Iterator = Cancer200Api.ImageIterator<Cancer200Api.AnyImage<Pixel>>
}
extension Cancer200Api.AnyImage : Swift.Equatable where Pixel : Swift.Equatable {
  public static func == (lhs: Cancer200Api.AnyImage<Pixel>, rhs: Cancer200Api.AnyImage<Pixel>) -> Swift.Bool
}
public enum FormErrorType : Swift.Error {
  case sectionOutOfIndex
  case rowOutOfIndex
  public static func == (a: Cancer200Api.FormErrorType, b: Cancer200Api.FormErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PremultipliedRGBA<Channel> where Channel : Swift.Comparable, Channel : Swift.Numeric {
  public var red: Channel
  public var green: Channel
  public var blue: Channel
  public var alpha: Channel
  public init(red: Channel, green: Channel, blue: Channel, alpha: Channel)
}
extension Cancer200Api.PremultipliedRGBA where Channel : Cancer200Api._NumericPixel, Channel : Swift.FixedWidthInteger, Channel : Swift.UnsignedInteger, Channel._NumericPixelSummableInt : Swift.FixedWidthInteger {
  public init(_ rgba: Cancer200Api.RGBA<Channel>)
}
extension Cancer200Api.PremultipliedRGBA where Channel : Swift.FloatingPoint {
  public init(_ rgba: Cancer200Api.RGBA<Channel>)
}
extension Cancer200Api.PremultipliedRGBA {
  public init(gray: Channel, alpha: Channel)
}
extension Cancer200Api.PremultipliedRGBA {
  public func map<T>(_ transform: (Channel) -> T) -> Cancer200Api.PremultipliedRGBA<T> where T : Swift.Comparable, T : Swift.Numeric
}
extension Cancer200Api.PremultipliedRGBA where Channel == Swift.UInt8 {
  public init(_ rgbaInt: Swift.UInt32)
}
extension Cancer200Api.PremultipliedRGBA : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Cancer200Api.PremultipliedRGBA : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Cancer200Api.PremultipliedRGBA : Swift.Equatable {
  @inlinable public static func == (lhs: Cancer200Api.PremultipliedRGBA<Channel>, rhs: Cancer200Api.PremultipliedRGBA<Channel>) -> Swift.Bool {
        return lhs.red == rhs.red && lhs.green == rhs.green && lhs.blue == rhs.blue && lhs.alpha == rhs.alpha
    }
  @inlinable public static func != (lhs: Cancer200Api.PremultipliedRGBA<Channel>, rhs: Cancer200Api.PremultipliedRGBA<Channel>) -> Swift.Bool {
        return lhs.red != rhs.red || lhs.green != rhs.green || lhs.blue != rhs.blue || lhs.alpha != rhs.alpha
    }
}
final public class FormDescriptor {
  final public var title: Swift.String
  final public var sections: [Cancer200Api.FormSectionDescriptor]
  public init()
  public init(title: Swift.String)
  final public func formValues() -> [Swift.String : Swift.AnyObject]
  final public func validateForm() -> Cancer200Api.FormRowDescriptor?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormLabelCell : Cancer200Api.FormValueCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
public struct ImageIterator<Pixels> : Swift.IteratorProtocol where Pixels : Cancer200Api.ImageProtocol {
  public typealias Element = Pixels.Element
  public mutating func next() -> Cancer200Api.ImageIterator<Pixels>.Element?
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class FormCheckCell : Cancer200Api.FormTitleCell {
  @_Concurrency.MainActor(unsafe) override open func configure()
  @_Concurrency.MainActor(unsafe) override open func update()
  @_Concurrency.MainActor(unsafe) override open class func formViewController(_ formViewController: Cancer200Api.FormViewController, didSelectRow selectedRow: Cancer200Api.FormBaseCell)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init(style: UIKit.UITableViewCell.CellStyle, reuseIdentifier: Swift.String!)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
extension Cancer200Api.FormRowDescriptor.RowType : Swift.Equatable {}
extension Cancer200Api.FormRowDescriptor.RowType : Swift.Hashable {}
extension Cancer200Api.SimulationType : Swift.Equatable {}
extension Cancer200Api.SimulationType : Swift.Hashable {}
extension Cancer200Api.SimulationType : Swift.RawRepresentable {}
extension Cancer200Api.StartLocation : Swift.Equatable {}
extension Cancer200Api.StartLocation : Swift.Hashable {}
extension Cancer200Api.StartLocation : Swift.RawRepresentable {}
extension Cancer200Api.ConfigurationManager.AppType : Swift.Equatable {}
extension Cancer200Api.ConfigurationManager.AppType : Swift.Hashable {}
extension Cancer200Api.ConfigurationManager.AppType : Swift.RawRepresentable {}
extension Cancer200Api.CGContextCoordinates : Swift.Equatable {}
extension Cancer200Api.CGContextCoordinates : Swift.Hashable {}
extension Cancer200Api.InterpolationMethod : Swift.Equatable {}
extension Cancer200Api.InterpolationMethod : Swift.Hashable {}
extension Cancer200Api.FormErrorType : Swift.Equatable {}
extension Cancer200Api.FormErrorType : Swift.Hashable {}
